10th of May -- morning

Is there a sensible way of running this on social network graphs?

2) Finish plumbing
3) find <k cycle algorithm to implement or use.

  -- Keep to-do list up to date
  -- Literature
    : Web-of-needs, and other related projects
    : Market performance metrics
      : What does ideal performance look like?
      : Dynamic setting
        : Average waiting time of user to get task fulfilled
  -- Think about graph-based heuristics
    : As you don't need to necessarily find 100% of the matches, 80%'d be fine
    : Start from cycle-basis?
  -- Look into realistic demographics for ON (offer network) instances
    : perhaps via e-bay developers program API?
    : try white-papers in industry
    : {Seems not that much good literature, many related things do something pretty artificial.}
      : 1) Draw edges for tasks from non-uniform distributions
      : 2) Graph with clusters of task-types
      - scale free seems awkward, well, depends on hub structure
      - why not try erdos-renyi
      - small-world seems cool
      Not really correct, but could be fun: https://snap.stanford.edu/data/p2p-Gnutella04.html
  -- Write code to generate ON instances (based on parameters)
    : Now with non-random instances!
  -- Adapt library / implement algorithm to match on instances
  -- Set up together as Simulator for experiments
  -- Run trials & measurements
    : Test, test, test!
  -- If time permits, try to extend features.
    : benefit of chains! (gifts!)
    : which methods would be easier to port to decentralized systems?


Personal Notes:

First, I'll break the P-time matching! Yargh!

ebay: (-- ONs)
      skewed degree distribution (there are a few big sellers)
        -- not likely in ONs, actually, likely almost none (at first)
      disassortativity (users don't necessarily look for products they sell)
        -- likely as well, although to a lesser degree than in ebay
            -- so, not much clustering
      densification (reputation)
        -- if the feature is added
      no rich club connectivity
        -- yeah, prolly not in particular
      only linear preferential attachment observed

Watts-Strogatz model:
  small world / clustering



Hmm, in random graphs,
  nodes == tasks
  edges == (offer, request) or (request, offer) (randomly choose again?)
    -- unless a random directed model.

Okay, sounds doable enough ;-)


watts_strogatz_graph(n, k, p, seed=None)[source]
Return a Watts-Strogatz small-world graph.

Parameters:
n (int) – The number of nodes
k (int) – Each node is connected to k nearest neighbors in ring topology
p (float) – The probability of rewiring each edge
seed (int, optional) – Seed for random number generator (default=None)



Okay, what sort of graph can I expect for offer networks?

I'd suspect there are no really big nodes, i.e., with an insane amount of offers.
... Actually, that's irrelevant as the matching is done irrespective of the users!
The question is task popularity.

First, yes, some tasks will likely be much more popular than others, both to offer and to request... and those don't have to be the same.... although if there's not some degree of match, then we're kinda fucked, tbh.

So one shouldn't really expect equal probability. What kind of distribution is to be expected though?
The ebay data implied tasks weren't really that clustered: people would offer things in one category and request them in another. I suspect this will be less the case with services than things (i.e., selling what you have). However, I guess this would imply task-clustering low but existent.

So scale free kinda makes sense with low (but not no) clustering.

http://expandedramblings.com/index.php/ebay-stats/ --> average of 4 ORpairs per user




Questions:
  -- Minimalistic, but sufficient that someone can REPRODUCE my work by reading my paper. So referenced papers' ideas you use will have to be explained sufficiently but not excessively.
  -- Do I really need the ORnodes? Or just edges?
    -- One reason is it's easier to represent matches
  -- Explain what a reputatation sytsem is and how it actually helps... and give references to some such systems, such as feedback in eBay and oDesk.
  -- Make it really self-contained, explain all terms, etc.
  -- For additional features, for example, explain what the terms actually mean and give some ideas as to their implementation
  -- Expand related work section
    -- including the abraham integre programming bit
  -- Specification title spelling
  -- plot size (obvious, but yeah)
  -- Keep track of hard and easy to match tasks!


Task centricity is, in a sense, a difference between yours and other similar investigations
